function Parameters = initializecoordinatedcontroller(Parameters)
%INITIALIZECOORDINATEDCONTROLLER Generate the optimal control problem of
% the coordinated controller.

% Luca Parolini
% <lparolin@andrew.cmu.edu>

% May 4th 2011

%NOTE: When we work with a tomArray having dimension [x, 1], the result is
%stored into an array of dimension [x]. For example
% 
%a =tom('a', 1000);
%b = tomarray(a, [100, 10, 1]);
%c = b(1:10,1:10,1)
%
% c = tomArray(1..10, 1..10) with tomSym data:
%  
%   a([... 100 by 1 array ...])
%
% We want c to be a (1..10, 1..10, 1) tomArray. In order to do this, we
% recast c as a tomArray with dimension [10, 10, 1].
%
%This workaround is use throughout the followin code.
%

%% check input variables
if ~isfield(Parameters.Controller, 'considerCostOfElectricity')
    Parameters.Controller.considerCostOfElectricity = false;
    logcomment('Parameters.Controller.considerCostOfElectricity not defined. Set it to false.');
    logcomment('Cost of electricity will be neglected');
end

if ~isfield(Parameters.Controller, 'Options')
    msgIdentComponent = upper(mfilename);
    msgIdentMnemonic = 'InputVariableCheck';
    msgIdent = [msgIdentComponent ':' msgIdentMnemonic];
    errorToThrow = MException(msgIdent, ...
        ['Parameters.Controller.Options not defined. Impossible to initialize ' ...
        'the coordinated controller']);
    logandthrowerror(errorToThrow);
end

if ~isfield(Parameters.Controller, 'trapezoidalApproximationNumberPoints')
    Parameters.Controller.trapezoidalApproximationNumberPoints = 3;
    logcomment('Set trapezoidalApproximationNumberPoints = 3');
end

if ~isfield(Parameters.Controller, 'trapezoidalApproximationOrder')
    Parameters.Controller.trapezoidalApproximationOrder = 2;
    logcomment('Set trapezoidalApproximationOrder = 2');
end

%% Make name of some variables short
nTimeSteps = Parameters.Controller.nHorizonTimeSteps;
nZones = Parameters.DcData.nZones;
nCracs = Parameters.DcData.nCracs;
nJobClasses = Parameters.DcData.nJobClasses;
cracTinMax = max(Parameters.DcData.zoneTinMax) * 5 * ones(nCracs, 1);
tinMax = [Parameters.DcData.zoneTinMax; cracTinMax];
relativeTimeStep = Parameters.Controller.timeStep / ...
    Parameters.Simulation.timeStep;

%% define the coefficients for the optimization problem
Parameters.Controller.queueLengthMax = ...
    Parameters.normalizedJobArrivalRateMax * 10;

% Controller time scale is so large that it is possible (and
% computationally convenient) to neglect the dynamic of the thermal
% part
Parameters.Controller.thermalSystemMatrixAThreshold = 0.01; 
Parameters.Controller.powerScalingCoefficient = ...
    1 / max(Parameters.DcData.zonePowerMax);

Parameters.Controller.normalizedWorkloadToPowerCoefficient = ...
    Parameters.DcData.jobDepartureRateToPowerConsumption * ...
    Parameters.Controller.powerScalingCoefficient;
    
Parameters.Controller.queueLengthCost = ones(nJobClasses, ...
    nJobClasses) * relativeTimeStep * Parameters.queueLengthMax;
Parameters.Controller.jobDropCost = ones(nJobClasses, ...
    nJobClasses) * relativeTimeStep * Parameters.normalizedDropCostMax;
Parameters.Controller.jobMigrationDropCost = ...
    Parameters.normalizedDropCostMax * Parameters.Controller.jobDropCost;
Parameters.Controller.jobExecutionRateCost = ones(nZones, ...
     nJobClasses) * relativeTimeStep;

Parameters.Controller.jobExecutionRateMax = Parameters.DcData.jobDepartureRateMax;

% compute thermal system
Parameters = computediscretetimethermalmatrices(Parameters);
discreteTimeMatrixA = Parameters.Controller.discreteTimeMatrixA;
discreteTimeMatrixBZonePower = ...
    Parameters.Controller.discreteTimeMatrixB(:, 1 : nZones);
discreteTimeMatrixBCracTref = ...
    Parameters.Controller.discreteTimeMatrixB(:, nZones + 1 : nZones + nCracs);
discreteTimeMatrixC = Parameters.Controller.discreteTimeMatrixC;

% state variables
normalizedQueueLength = createcelloftomarray('l', nTimeSteps + 1, ...
    [nZones, nJobClasses]);
Tout = createcelloftomsym('Tout', nTimeSteps + 1, ...
    [nZones + nCracs, 1]);

% input variables
jobArrivalRateToDataCenter = createcelloftomsym('lambda', nTimeSteps, ...
    [nJobClasses, 1]);
jobArrivalRateToZone = createcelloftomarray('lambdaij', nTimeSteps, ...
    [nZones, nJobClasses]);
jobExecutionRate = createcelloftomarray('mu', nTimeSteps, ...
    [nZones, nJobClasses]);
referenceTemperature = createcelloftomsym('Tref', nTimeSteps, ...
    [nCracs, 1]);

% buffer length after workload migration
normalizedNewQueueLength = createcelloftomarray('lTilde', nTimeSteps, ...
    [nZones, nJobClasses]);

% normalizedPowerCost = createcelloftomsym('powerCost', nTimeSteps, [1, 1]);
normalizedElectricityCostLow = createcelloftomsym('alpha', nTimeSteps, [1, 1]);
normalizedElectricityCostHigh = createcelloftomsym('beta', nTimeSteps, [1, 1]);
normalizedPowerConsumptionThreshold = createcelloftomsym('pwThreshold', nTimeSteps, [1, 1]);

% tomArrayIdx
iZoneIdx = tomArrayIdx('iZone', 1 : nZones);
iJobClassIdx = tomArrayIdx('iJobClass', 1 : nJobClasses);
% second tomArray index for job class
jJobClassIdx = tomArrayIdx('jJobClass', 1 : nJobClasses);

% tomArray constants
jobExecutionRateMaxTomArray = tomArray(Parameters.Controller.jobExecutionRateMax, ...
    size(Parameters.Controller.jobExecutionRateMax));
queueLengthCostTomArray = tomArray(Parameters.Controller.queueLengthCost, ...
    size(Parameters.Controller.queueLengthCost) );
jobDropCostTomArray = tomArray(Parameters.Controller.jobDropCost, ...
    size(Parameters.Controller.jobDropCost) );
jobMigrationDropCostTomArray = tomArray(Parameters.Controller.jobDropCost, ...
    size(Parameters.Controller.jobMigrationDropCost) );
normalizedWorkloadToPowerCoefficient = tomArray( ...
    Parameters.Controller.normalizedWorkloadToPowerCoefficient, ...
    size(Parameters.Controller.normalizedWorkloadToPowerCoefficient) );
jobExecutionRateCostTomArray = tomArray( ...
    Parameters.Controller.jobExecutionRateCost, ...
    size(Parameters.Controller.jobExecutionRateCost) );

% generate the optimization problem, one step at time
computationalDynamics = cell(nTimeSteps, 1);
jobMigrationConstraint = cell(nTimeSteps, 1);
controlConstraint = cell(nTimeSteps, 1);
stateConstraint = cell(nTimeSteps, 1);
thermalDynamics = cell(nTimeSteps, 1);
objectiveFunction = 0;

% Store variables to recover estimated values at simulation time
normalizedDeparture = cell(nTimeSteps, 1);
normalizedZonePowerConsumption = cell(nTimeSteps, 1);
% normalizedCracPowerConsumption = cell(nTimeSteps, nCracs);
normalizedCracPowerConsumption = cell(nTimeSteps);
costDropJob = cell(nTimeSteps, 1);
costMigrationJobDrop = cell(nTimeSteps, 1);
costQueueLength = cell(nTimeSteps, 1);
costZonePowerConsumption = cell(nTimeSteps, 1);
costCracPowerConsumption = cell(nTimeSteps, 1);
normalizedDataCenterPowerConsumption = cell(nTimeSteps, 1);
normalizedCostPowerConsumptionLow = cell(nTimeSteps, 1);
normalizedCostPowerConsumptionHigh = cell(nTimeSteps, 1);
costPowerConsumption = cell(nTimeSteps, 1);


%% Formulate the optimization problem
logcomment('Defining coordinated controller optimization problem.');
for iTimeStep = 1 : nTimeSteps
    % rewrite the non-linear queue evolution as a collection of linear
    % inequalities
%     computationalTemp1 = ...
%         normalizedNewQueueLength{iTimeStep}(iZoneIdx, iJobClassIdx) + ...
%         jobArrivalRateToZone{iTimeStep}(iZoneIdx, iJobClassIdx) - ...
%         jobExecutionRate{iTimeStep}(iZoneIdx, iJobClassIdx);
    
    normalizedDeparture{iTimeStep} = ...
        normalizedNewQueueLength{iTimeStep}(iZoneIdx, iJobClassIdx) + ...
        jobArrivalRateToZone{iTimeStep}(iZoneIdx, iJobClassIdx) - ...
        normalizedQueueLength{iTimeStep + 1}(iZoneIdx, iJobClassIdx);
    % recast normalizedDeparture
    normalizedDeparture{iTimeStep} = ...
        tomArray(normalizedDeparture{iTimeStep}, [nZones, nJobClasses]);
    
    computationalTemp1 = ...
        normalizedNewQueueLength{iTimeStep}(iZoneIdx, iJobClassIdx) + ...
        jobArrivalRateToZone{iTimeStep}(iZoneIdx, iJobClassIdx) - ...
        normalizedDeparture{iTimeStep}(iZoneIdx, iJobClassIdx);
    % recast computationalTemp1
    computationalTemp1 = tomArray(computationalTemp1, [nZones, nJobClasses]);
    
    if nJobClasses == 1
        normalizedZonePowerConsumption{iTimeStep} = ...
            normalizedDeparture{iTimeStep}(iZoneIdx, iJobClassIdx) .* ...
            normalizedWorkloadToPowerCoefficient(iZoneIdx, iJobClassIdx);
    else
        normalizedZonePowerConsumption{iTimeStep} = ...
            sum(normalizedDeparture{iTimeStep}(iZoneIdx, iJobClassIdx) .* ...
                normalizedWorkloadToPowerCoefficient(iZoneIdx, iJobClassIdx), ...
                iJobClassIdx);
    end
   
    for iCrac = 1 : nCracs
        normalizedCracPowerConsumption{iTimeStep, iCrac} = ...
            powercractrapezoidalapproximation(Parameters, ...
            Parameters.Controller.trapezoidalApproximationNumberPoints, ...
            Tout{iTimeStep}, referenceTemperature{iTimeStep}, ...
            normalizedZonePowerConsumption{iTimeStep}, iCrac);
    end
    
    totalCracPowerConsumption = 0;
    for iCrac = 1 : nCracs
        totalCracPowerConsumption = totalCracPowerConsumption + ...
            normalizedCracPowerConsumption{iTimeStep, iCrac};
    end
    computationalDynamics{iTimeStep} = { ...
        vec(normalizedQueueLength{iTimeStep + 1}) >= vec(computationalTemp1) ...
        vec(normalizedDeparture{iTimeStep}) <= vec(jobExecutionRate{iTimeStep}) ...
        vec(normalizedDeparture{iTimeStep}) >= 0 ...
    };

    % thermal part
    thermalDynamics{iTimeStep} = { ...
        Tout{iTimeStep + 1} == discreteTimeMatrixA * Tout{iTimeStep} + ...
        discreteTimeMatrixBZonePower * vec(normalizedZonePowerConsumption{iTimeStep}) + ...
        discreteTimeMatrixBCracTref * referenceTemperature{iTimeStep} ...
    };
    
    jobMigrationConstraint{iTimeStep} = { ...
        vec(normalizedNewQueueLength{iTimeStep}) >= 0 ...
        vec(normalizedNewQueueLength{iTimeStep}) <= ...
            vec(Parameters.Controller.queueLengthMax) ...
        vec(sum(normalizedNewQueueLength{iTimeStep}(iZoneIdx, iJobClassIdx), iZoneIdx)) <= ...
            vec(sum(normalizedQueueLength{iTimeStep}(iZoneIdx, iJobClassIdx), iZoneIdx)) ...
    };

    totalJobArrivalRatePerJobClass = ...
        sum(jobArrivalRateToZone{iTimeStep}(iZoneIdx, iJobClassIdx), iZoneIdx);
    
    inputTemperatureTmp = discreteTimeMatrixC * Tout{iTimeStep + 1};
    inputCracTemperature = inputTemperatureTmp(Parameters.DcData.cracIdx);
    controlConstraint{iTimeStep} = { ...
        vec(jobArrivalRateToZone{iTimeStep}) >= 0 ...
        vec(jobArrivalRateToZone{iTimeStep}) <= 10 ...
        vec(totalJobArrivalRatePerJobClass) <= vec(jobArrivalRateToDataCenter{iTimeStep}) ...
        vec(jobExecutionRate{iTimeStep}) >= 0 ...
        vec(jobExecutionRate{iTimeStep}) <= vec(jobExecutionRateMaxTomArray) ...
        vec(referenceTemperature{iTimeStep}) >= Parameters.DcData.trefMin ...
        vec(referenceTemperature{iTimeStep}) <= Parameters.DcData.trefMax ...
        vec(referenceTemperature{iTimeStep}) <= inputCracTemperature ...
    };

    stateConstraint{iTimeStep} = { ...
        vec(normalizedQueueLength{iTimeStep + 1}) >= 0 ...
        vec(normalizedQueueLength{iTimeStep + 1}) <= Parameters.Controller.queueLengthMax ...
        Tout{iTimeStep + 1} >= 0 ...
        Tout{iTimeStep + 1} <= 100 ...
        discreteTimeMatrixC * Tout{iTimeStep + 1} <= tinMax ...
    };

    if nJobClasses == 1
        costDropJobPart2 = vec(jobArrivalRateToZone{iTimeStep}) .* ...
            vec(jobArrivalRateToZone{iTimeStep}) * vec(jobDropCostTomArray);
                jobDropCostTomArray(iJobClassIdx, jJobClassIdx);
        costDropJobPart2 = tomArray(costDropJobPart2, [nZones, nJobClasses]);
    else
        costDropJobPart1 = sum(jobArrivalRateToZone{iTimeStep}(iZoneIdx, iJobClassIdx) .* ...
                jobDropCostTomArray(iJobClassIdx, jJobClassIdx), iJobClassIdx);
        costDropJobPart2 = ...
            sum(costDropJobPart1(iZoneIdx, jJobClassIdx) .* ...
                jobArrivalRateToZone{iTimeStep}(iZoneIdx, jJobClassIdx), jJobClassIdx);
    end
    
    costDropJob{iTimeStep} = -sum(vec(costDropJobPart2));
        
    jobDifference = normalizedQueueLength{iTimeStep} - ...
        normalizedNewQueueLength{iTimeStep};
    jobDifference = tomArray(jobDifference, ...
        [nZones, nJobClasses]);
    
    if nJobClasses == 1
        costMigrationJobDropPart2 = vec(jobDifference) .* ...
            vec(jobDifference) * vec(jobMigrationDropCostTomArray);
        costMigrationJobDropPart2 = tomArray(costMigrationJobDropPart2, ...
            [nZones, nJobClasses]);
        
    else
        costMigrationJobDropPart1 = sum(jobDifference(iZoneIdx, iJobClassIdx) .* ...
            jobMigrationDropCostTomArray(iJobClassIdx, jJobClassIdx), iJobClassIdx);
        costMigrationJobDropPart2 = ...
            sum(costMigrationJobDropPart1(iZoneIdx, jJobClassIdx) .* ...
                jobDifference(iZoneIdx, jJobClassIdx), jJobClassIdx);
    end
    costMigrationJobDrop{iTimeStep} = sum(vec(costMigrationJobDropPart2));
    
    if nJobClasses == 1
        costQueueLengthPart2 = ...
            vec(normalizedQueueLength{iTimeStep + 1}) .* ...
            vec(normalizedQueueLength{iTimeStep + 1}) * ...
            vec(queueLengthCostTomArray);
        costQueueLengthPart2 = tomArray(costQueueLengthPart2, ...
            [nZones, nJobClasses]);
    else
        costQueueLengthPart1 = ...
            sum(normalizedQueueLength{iTimeStep + 1}(iZoneIdx, iJobClassIdx) .* ...
                queueLengthCostTomArray(iJobClassIdx, jJobClassIdx), iJobClassIdx);
        costQueueLengthPart2 = ...
            sum(costQueueLengthPart1(iZoneIdx, jJobClassIdx) .* ...
                normalizedQueueLength{iTimeStep + 1}(iZoneIdx, jJobClassIdx), jJobClassIdx);
    end
    costQueueLength{iTimeStep} = sum(vec(costQueueLengthPart2));
    
    if nJobClasses == 1
        costExecutionRatePart2 = ...
            vec(jobExecutionRate{iTimeStep}).* ...
            vec(jobExecutionRate{iTimeStep}) .* ...
            vec(jobExecutionRateCostTomArray);
        costExecutionRatePart2 = ...
            tomArray(costExecutionRatePart2, [nZones, nJobClasses]);
    else
        costExecutionRatePart1 = ...
            sum(jobExecutionRate{iTimeStep}(iZoneIdx, iJobClassIdx) .* ...
               jobExecutionRateCostTomArray(iZoneIdx, jJobClassIdx), iJobClassIdx);
        costExecutionRatePart2 = ...
            sum(costExecutionRatePart1(iZoneIdx, jJobClassIdx) .* ...
               jobExecutionRate{iTimeStep}(iZoneIdx, jJobClassIdx), jJobClassIdx);
    end
    
    if Parameters.Controller.considerCostOfElectricity 
        logcomment('Considering the cost of electricity');
        normalizedDataCenterPowerConsumption{iTimeStep} = ...
            sum(vec(normalizedZonePowerConsumption{iTimeStep}) ) + ...
            totalCracPowerConsumption;

        normalizedCostPowerConsumptionLow{iTimeStep} = normalizedElectricityCostLow{iTimeStep} * ...
            normalizedDataCenterPowerConsumption{iTimeStep};
        normalizedCostPowerConsumptionHigh{iTimeStep} = normalizedElectricityCostLow{iTimeStep} * ...
            normalizedPowerConsumptionThreshold{iTimeStep} + ...
            normalizedElectricityCostHigh{iTimeStep} * ...
            (normalizedDataCenterPowerConsumption{iTimeStep} - normalizedPowerConsumptionThreshold{iTimeStep});
        costPowerConsumption{iTimeStep} = ...
            max(normalizedCostPowerConsumptionHigh{iTimeStep}, normalizedCostPowerConsumptionLow{iTimeStep});

        objectiveFunction = objectiveFunction + costQueueLength{iTimeStep} + ...
            costDropJob{iTimeStep} + costMigrationJobDrop{iTimeStep} + ...
            costPowerConsumption{iTimeStep} + sum(vec(costExecutionRatePart2));
    else
        normalizedDataCenterPowerConsumption{iTimeStep} = ...
            sum(vec(normalizedZonePowerConsumption{iTimeStep}) ) + ...
            totalCracPowerConsumption;

        costPowerConsumption{iTimeStep} = ...
            normalizedDataCenterPowerConsumption{iTimeStep};
        
        objectiveFunction = objectiveFunction + costQueueLength{iTimeStep} + ...
            costDropJob{iTimeStep} + costMigrationJobDrop{iTimeStep} + ...
            costPowerConsumption{iTimeStep} + sum(vec(costExecutionRatePart2));
    end
end

% normalize by the number of time steps
objectiveFunction = objectiveFunction / nTimeSteps;

constraint = {computationalDynamics thermalDynamics jobMigrationConstraint ...
    controlConstraint stateConstraint}; % additionalCracConstraint

%% generate the numerical optimization problem
Parameters.Controller.Options.name = 'Data center level coordinated optimization problem.';
Options = Parameters.Controller.Options;

logcomment('Generating coordinated controller optimization problem...');
tic
Parameters.Controller.OptimizationProblem = ...
    sym2prob(Parameters.Controller.Options.type, objectiveFunction, ...
    constraint, [], Options);

Parameters.Controller.generationTime = toc;
logcomment(['Coordinated controller optimization generated in ' ...
    num2str(Parameters.Controller.generationTime) 's.']);
  

%% Store variables to recover estimated values at simulation time
Parameters.Controller.Variables = struct;
Parameters.Controller.Variables.objectiveFunction = objectiveFunction;
Parameters.Controller.Variables.normalizedQueueLength = ...
    normalizedQueueLength;
Parameters.Controller.Variables.normalizedNewQueueLength = ...
    normalizedNewQueueLength;
Parameters.Controller.Variables.Tout = ...
    Tout;
Parameters.Controller.Variables.jobExecutionRate = ...
    jobExecutionRate;
Parameters.Controller.Variables.jobArrivalRateToDataCenter = ...
    jobArrivalRateToDataCenter;
Parameters.Controller.Variables.jobArrivalRateToZone = ...
    jobArrivalRateToZone;
Parameters.Controller.Variables.normalizedElectricityCostLow = ...
    normalizedElectricityCostLow;
Parameters.Controller.Variables.normalizedElectricityCostHigh = ...
    normalizedElectricityCostHigh;
Parameters.Controller.Variables.normalizedPowerConsumptionThreshold = ...
    normalizedPowerConsumptionThreshold;
Parameters.Controller.Variables.jobExecutionRate = ...
    jobExecutionRate;
Parameters.Controller.Variables.referenceTemperature = ...
    referenceTemperature;
Parameters.Controller.Variables.normalizedDeparture = ...
    normalizedDeparture;
Parameters.Controller.Variables.normalizedZonePowerConsumption = ...
    normalizedZonePowerConsumption;
Parameters.Controller.Variables.normalizedCracPowerConsumption = ...
    normalizedCracPowerConsumption;
Parameters.Controller.Variables.costDropJob = ...
    costDropJob;
Parameters.Controller.Variables.costMigrationJobDrop = ...
    costMigrationJobDrop;
Parameters.Controller.Variables.costQueueLength = ...
    costQueueLength;
Parameters.Controller.Variables.costZonePowerConsumption = ...
    costZonePowerConsumption;
Parameters.Controller.Variables.costCracPowerConsumption = ...
    costCracPowerConsumption;
Parameters.Controller.Variables.normalizedDataCenterPowerConsumption = ...
    normalizedDataCenterPowerConsumption;
Parameters.Controller.Variables.normalizedCostPowerConsumptionLow = ...
    normalizedCostPowerConsumptionLow;
Parameters.Controller.Variables.normalizedCostPowerConsumptionHigh = ...
    normalizedCostPowerConsumptionHigh;
Parameters.Controller.Variables.costPowerConsumption = ...
    costPowerConsumption;
 

if Parameters.Controller.considerCostOfElectricity 
    UncontrollableVariableName = {'jobArrivalRateToDataCenter', ...
        'normalizedElectricityCostLow', 'normalizedElectricityCostHigh', ...
        'normalizedPowerConsumptionThreshold'};
else
    UncontrollableVariableName = {'jobArrivalRateToDataCenter'};
end

Parameters.Controller.PredictedVariablesIdx = ...
    computevariableindex(Parameters, UncontrollableVariableName, nTimeSteps);
 
StateVariableName = {'normalizedQueueLength', 'Tout'};
Parameters.Controller.StateVariablesIdx = ...
    computevariableindex(Parameters, StateVariableName, 1);

% open matlab pool
SchedulerResource = findResource();
clusterSizeMax = SchedulerResource.ClusterSize;

% check the maximum allowed number of parallel workers
if Parameters.Controller.poolSize > clusterSizeMax
    logcomment(['Parameters.Controller.poolSize exceeds maximum ' ...
        'cluster size value. Parameters.Controller.poolSize=' ...
        num2str(Parameters.Controller.poolSize) ...
        ' maximum cluster size=' num2str(clusterSizeMax)]);
    Parameters.Controller.poolSize = clusterSizeMax;
    logcomment(['Parameters.Controller.poolSize set to ' ...
        num2str(clusterSizeMax)]);
end

isPoolRightSize = matlabpool('size') == Parameters.Controller.poolSize;
if (~isPoolRightSize) && (Parameters.Controller.isParallelExeuctionRequired)
    isPoolOpen = matlabpool('size') > 0;
    if isPoolOpen
        logcomment('Closing MATLAB pool...');
        matlabpool close;
    end
    logcomment('Opening MATLAB pool...');
    matlabpool('open', Parameters.Controller.poolSize);
end

Parameters.Controller.Prediction.time = Parameters.Simulation.time;
Parameters.Controller.Prediction.objectiveFunction = ...
    Parameters.Simulation.time;
Parameters.Controller.Prediction.zonePowerConsumption = ...
    Parameters.Simulation.zonePowerConsumption;
Parameters.Controller.Prediction.outputTemperature = ...
    Parameters.Simulation.outputTemperature;
Parameters.Controller.Prediction.inputTemperature = ...
    Parameters.Simulation.inputTemperature;
Parameters.Controller.Prediction.cracPowerConsumption = ...
    Parameters.Simulation.cracPowerConsumption;
Parameters.Controller.Prediction.queueLength = ...
    Parameters.Simulation.queueLength;
Parameters.Controller.Prediction.jobArrivalRateToZone = ...
    Parameters.Simulation.jobArrivalRateToZone;
Parameters.Controller.Prediction.jobArrivalRateToDataCenter = ...
    Parameters.Simulation.jobArrivalRateToDataCenter;
Parameters.Controller.Prediction.totalCost = Parameters.Simulation.totalCost;
Parameters.Controller.Prediction.costZonePowerConsumption = ...
    Parameters.Simulation.totalCost;
Parameters.Controller.Prediction.costDropJob = ...
    Parameters.Simulation.totalCost;
Parameters.Controller.Prediction.costMigrationJobDrop = ...
    Parameters.Simulation.totalCost;
Parameters.Controller.Prediction.costQueueLength = ...
    Parameters.Simulation.totalCost;
end


function powerCracAverage = powercractrapezoidalapproximation(Parameters, ...
    nPoints, outputTemperature, referenceTemperature, zonePowerConsumption, ...
    cracIdx)
    persistent ContinousTimeMatrices;
    persistent DiscreteTimeMatrices;
    
    if isempty(ContinousTimeMatrices)
        ContinousTimeMatrices = struct;
        ContinousTimeMatrices.a = Parameters.Controller.continousTimeMatrixA;
        ContinousTimeMatrices.b = Parameters.Controller.continousTimeMatrixB;
        ContinousTimeMatrices.c = Parameters.DcData.psi;
        ContinousTimeMatrices.d = [];
    end
    
    if isempty(DiscreteTimeMatrices)
        clear DiscreteTimeMatrices; % so that we can recreate the empty 
            % variable as an array of struct
            
        % Recomputing the stateupdate (Adt) and input-state matrix (Bdt) 
        % every iteration, allows us to refer always to the initial output 
        % and power consumption temperature.
        % Also, this approach allows us to reduce numerical instabilities due
        % to small values of the Adt, or Bdt matrix
        for iPoint = (nPoints - 1) : -1 : 1
            dt = Parameters.Controller.timeStep / (nPoints - 1) * iPoint;
            DiscreteTimeMatrices(iPoint) = ...
                computeapproximationmatrices(ContinousTimeMatrices, dt, ...
                Parameters.Controller.thermalSystemMatrixAThreshold, ...
                Parameters.Controller.thermalSystemSingularvalueRatioThreshold);
        end        
    end

    % tin = cell(nPoints, 1);
    % tout = cell(nPoints, 1);
    powerCracPartial = cell(nPoints, 1);
    nZones = Parameters.DcData.nZones;
    
    originalTout = outputTemperature;
    nextTin = DiscreteTimeMatrices(1).c * originalTout;    

    % copParameters = Parameters.DcData.cop.(['CRAC_' num2str(cracIdx)]);
    copParameters = Parameters.DcData.cop(cracIdx, :)';
    powerCracPartial{1} = approximatecracpowerconsumption(copParameters, ...
        Parameters.DcData.airFlow(nZones + cracIdx), ...
        Parameters.CONSTANT.AIR_HEAT_CAPACITY, ...
        Parameters.Controller.powerScalingCoefficient, ...
        Parameters.Controller.cracApproximationInitialTin, ...
        Parameters.Controller.cracApproximationInitialTout, ...
        nextTin(nZones + cracIdx), originalTout(nZones + cracIdx), ...
        Parameters.Controller.trapezoidalApproximationOrder);
    
    for iPoint = 1 : nPoints - 1
        nextTout = DiscreteTimeMatrices(iPoint).a * originalTout + ...
            DiscreteTimeMatrices(iPoint).b(:, Parameters.DcData.zoneIdx) * ...
            vec(zonePowerConsumption) +  ...
            DiscreteTimeMatrices(iPoint).b(:, Parameters.DcData.cracIdx) * ...
            referenceTemperature;
        nextTin = DiscreteTimeMatrices(iPoint).c * nextTout;

        % approximate crac power consumption via a third order taylor expansion
        powerCracPartial{iPoint + 1} = approximatecracpowerconsumption( ...
            copParameters, ...
            Parameters.DcData.airFlow(nZones + cracIdx), ...
            Parameters.CONSTANT.AIR_HEAT_CAPACITY, ...
            Parameters.Controller.powerScalingCoefficient, ...
            Parameters.Controller.cracApproximationInitialTin, ...
            Parameters.Controller.cracApproximationInitialTout, ...
            nextTin(nZones + cracIdx), nextTout(nZones + cracIdx), ...
            Parameters.Controller.trapezoidalApproximationOrder);
    end

    powerCracPartialAverage = powerCracPartial{1};
    for iPoint = 2 : nPoints - 1
        powerCracPartialAverage = powerCracPartialAverage + ...
            2 * powerCracPartial{iPoint};
    end
    powerCracPartialAverage = powerCracPartialAverage + ...
        powerCracPartial{end};
    powerCracAverage = powerCracPartialAverage / (2 * (nPoints-1));
end


function VariableIdx = computevariableindex(Parameters, CellOfVariableName, nTimeSteps)
    % Preallocate memory for the struct
    VariableIdx(nTimeSteps).(CellOfVariableName{1}) = [];
    for iVariableName = 1 : length(CellOfVariableName)
        for iHorizonTimeStep = 1 : nTimeSteps
            currentVariableName = CellOfVariableName{iVariableName};
            if iscell(Parameters.Controller.Variables.(currentVariableName))
                variableNameInOptimizationProblem = ...
                    num2str(vec(Parameters.Controller.Variables.(currentVariableName){iHorizonTimeStep}));
            else
                % we are not dealying with a cell type of variable.
                % Therefore, we expect nTimeSteps = 1, we make this check
                % for safety
                if nTimeSteps > 1
                    msgIdentComponent = upper(mfilename);
                    msgIdentMnemonic = 'InputVariableCheck';
                    msgIdent = [msgIdentComponent ':' msgIdentMnemonic];
                    errorToThrow = MException(msgIdent, ...
                        ['Unexpected values of variables. nTimeSteps > 1 ' ...
                        'and Parameters.Controller.Variables.' ...
                        currentVariableName ' is not a cell']);
                    logandthrowerror(errorToThrow);
                else
                    variableNameInOptimizationProblem = ...
                    num2str(Parameters.Controller.Variables.(currentVariableName));
                end
            end
            variableNameIdx = ...
                Parameters.Controller.OptimizationProblem.tomSym.idx.(variableNameInOptimizationProblem);
            VariableIdx(iHorizonTimeStep).(currentVariableName) = variableNameIdx;
        end
    end
end
